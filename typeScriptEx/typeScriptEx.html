<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
            // let a: number=1;
            // let b: string="hello";
            // let c: boolean=true;
            // let arr: number[]=[1,2];
            // console.log(arr);

            // const player:{
            //     name: string,
            //     age?:number //?을 사용해 준다~~(설정을 안할지 3항 연산자로 계산하나봐)
            // }={
            //     name: "noma"
            // }

            // //위에서 3항으로 true을 먼저 확인하고(위에 옵션이 있는지 보고 다음 비교연산자르 실행)
            //자바스크립트에서는
            // if(player.age<10){ 이렇게 실행되서 뻑가는 경우가 많거든 ㅠㅠ}

            // if(player.age && player.age<10){

            // }
            // player.name
            // type Player={
            //      name: string,
            //     age?:number
            // }

            // // const player:{
            // //     name: string,
            // //     age?:number //?을 사용해 준다~~(설정을 안할지 3항 연산자로 계산하나봐) 이게 너무 편하다~~
            // // }={
            // //     name: "noma"
            // // }

            // const snow:Player={
            //     age:12,
            //     name:"snow"
            // }

            // const Lynn:Player={
            //     name:"Lynn"
            // }

            //알아서 상속 받는게 너무 편한데???? 대박스!
            //펑션에 플레이어라고 명시만 해주면 위의 타입을 모두 상속받는다
            // type Player={
            //      name: string,
            //     age?:number
            // }

            //에로우 펑션
            // const playerMaker=(name:string):Player=>{name};

            //펑션형
            // function playerMaker(name:string): Player{
            //     return {name}
            // }
            // const playerMaker=(name:string): Player=>{
            //     return{
            //         name
            //     }
            // }

            // const hana=playerMaker("hana");
            // const nico=playerMaker("nico");
            // nico.age=10;

            //읽기전용 타입만들기 타입스크립트로 private을 알아서 걸어줬네! 캡슐화 시켜줬음
            // const item:readonly [string, number, boolean]=["tv", 2022, true];
            // item[1]=1;

            //any
            //자바스크립트의 허용을 쓰고 싶을 때 정의함

            // let a1:unknown;
            // //작업을 하려면 a1의 변수타입을 먼저 확인 해야함→ 조건문으로 체크( api 에서 엉뚱한게 들어오면 이걸로 타입 걸어놓고 if로 거르기)
            // //if문에서 분기를 갈려줌 첫번째 if는 넘버로 세팅
            // if(typeof a1=== "number"){
            //     let b1=a1+1;
            // }
            // else if(typeof a1==="string"){
            //     a1.toUpperCase();
            // }

            // //리턴없는 함수 void 자동 인식:void 써도 되긴 한데
            // function hello(){
            //     console.log("x")
            // }
            // const aUp=hello();
            // // aUp.toUpperCase();  //오류로 보이드 타입에 결과를 수정하잖아 하고 에러가 뜸

            //never
            //이건 절대 리턴 안되는 곳에 쓰이는데 평소 펑션 에러 잡을 떄 좋겠다!! ex
            // function hello(name:string|number) {
            //         name:
            // }

            // type Add={
            //     (a:number, b:number): number    //리턴도 넘버! 이걸알려주나봐
            //     //(a:number, b:string): number    //리턴도 넘버! 이걸알려주나봐
            //     (a:number, b:number, c:number):number
            // }

            // // const add =(a:number,b:number)=>a+b;

            // // 타입을 미리 세팅하고 함수에 가져가서 사용하기
            // const add: Add=(a,b)=> {
            //     if(typeof b=="string")return a;
            //     return a+b;
            // }

            // const add1:Add=(a,b,c?:number)=>{
            //     return c? a+b+c:a+b;
            // }

            // add1(1,2);
            // add1(1,3,2);

            // type Config={
            //     path: string,
            //     state: object
            // }

            // type Push={
            //     (path:string):void
            //     (config:Config):void;
            // }

            // const push:Push=(config)=>{
            //     //  if(typeof config==="string") {
            //     //     console.log(config);
            //     //  }else {
            //     //     console.log(config.path, config.state);
            //     //  }

            //     typeof config==="string"? console.log(config):console.log(config.path, config.state);

            // //다형성 폴리머피즘(多形)
            // type SuperPrint={
            //     // (arr:number[]):void
            //     // (arr: boolean[]):void //리턴값이 없을때는 보이드라고 적어줌
            //     // (arr:string[]):void
            //     //<T>(arr:T[])):void;   //제너릭 표현 그냥 나열만 해줘도 되네
            //     // <TypePlaceholder>(arr: TypePlaceholder[]):void;
            //     // <PrintItem>(arr:PrintItem[]):void;  //제너릭을 정해주면 알아서 기본타입을 타입스크립트가 찾아줌
            // <PrintItem>(arr:PrintItem[]):PrintItem;  //리턴값이 있을 때는 똑같이 제너릭 써주만 돼

            // }
            // // const superPrint:SuperPrint =(arr)=>{
            // //     arr.forEach(i=> console.log(i));
            // // }

            // const superPrint:SuperPrint =(arr)=>    arr[0];

            // const f=superPrint([1,2,3,4]);
            // const g=superPrint([true,false,true]);
            // const r=superPrint(["1","2"]);
            // const e=superPrint([1,2,3,4,true]);

            //다형성 폴리머피즘(多形)2

            // type SuperPrint={
            //     // (arr:number[]):void
            //     // (arr: boolean[]):void //리턴값이 없을때는 보이드라고 적어줌
            //     // (arr:string[]):void
            //         // <T>(arr:T[]):T;   //제너릭 표현 그냥 나열만 해줘도 되네
            //         <T,V>(arr:T[], b:V):T;   //제너릭 표현 그냥 나열만 해줘도 되네
            //     // <TypePlaceholder>(arr: TypePlaceholder[]):void;
            //     // <PrintItem>(arr:PrintItem[]):void;  //제너릭을 정해주면 알아서 기본타입을 타입스크립트가 찾아줌
            //     // <PrintItem>(arr:PrintItem[]):PrintItem;  //리턴값이 있을 때는 똑같이 제너릭 써주만 돼

            // }
            // // const superPrint:SuperPrint =(arr)=>{
            // //     arr.forEach(i=> console.log(i));
            // // }

            // const superPrint:SuperPrint=(a)=>a[0];

            // const f=superPrint([1,2,3,4],"x");
            // const g=superPrint([true,false,true],2);
            // const r=superPrint(["1","2"],true);
            // const e=superPrint([1,2,3,4,true],[]);

            // //제너릭을 아래와 같이 사용도 가능함
            // function printAllNum(arr:Array<number>){
            //     arr.forEach(i=>console.log(i))
            // }
            // function printAllStr(arr:Array<string>){
            //     arr.forEach(i=>console.log(i))
            // }

            // // printAllNum(["2",3,3]);  //str 오류
            // printAllNum([3,3]);
            // // printAllStr(['str',2]); //num이라 오류
            // printAllStr(["hello","type"]);

            // //만약에 리액트에 typeScript을 사용한다
            // //useState() (x)
            // //useState<number>();       //타입을 확정해서 리액트에 알려줌

            //타입스크립트로 객체지향프로그래밍을 해보자   //자바시간 같아 ㅋㅋㅋ
            //추상 클래스(여기서는 User)는 오직 다른 곳에 상속받을 수있는 클래스 인스턴스(상품/ 객체)을 직접 만들 수 없음
            // abstract class User{
            //     constructor(
            //         private firstName:string,   //js로 보면 바로 this으로 처리해주고 메서드 인자로 처리해줌
            //         private lastName:string,
            //         public nickname:string
            //     ){}
            //     getFullName(){
            //         return `${this.firstName} ${this.lastName}`;
            //     }
            //     //이렇게 하면 private 메서드도 만들 수 있다
            //     private setFullName(){
            //         return `${this.getFullName()}`;
            //     }
            //     //추상메서드도 가능하다! 추상메서드란? 상속받은 곳에서 직접 설계할 수 있는 폼만 있는 형태의 메서드
            //     //여기서는 Player따로 기능을 만들어줘야함
            //     abstract getNickName():void;
            // }

            // class Player extends User{
            //      getNickName(){
            //         console.log(this.nickname);
            //     }
            // }

            // const mita=new Player("mita", "sato", "moja");
            // // const moja=new User("mita", "sato", "moja"); (x)

            // mita.nickname="moni";
            // mita.getFullName();

            //해시맵
            // type Words={
            //     //오브젝트 타입을 설정
            //     [key:string]:string
            // }
            // class Dict{
            //     private words:Words;
            //     //컨스터럭쳐에 넣어야 하나? 컨스트럭쳐가 수동으로 인잇해준데? 와이??
            //     constructor(){
            //         this.words={}
            //     }
            //     add(word:Word){
            //         if(this.words[word.term]===undefined){
            //             this.words[word.term]=word.def;
            //         }
            //     }
            //     getWord(term:string){
            //         return this.words[term];
            //     }
            // }

            // class Word{
            //     constructor(
            //         public term:string,
            //         public def:string){}
            // }

            // const kimchi=new Word("kimchi", "koreaFood");

            // const dict= new Dict();
            // dict.add(kimchi);
            // dict.getWord("kimchi");

            // //Recap  망했다 여기 어려운데??
            //인터페이스

            // type Nickname=string;
            // type HealthBar=number;
            // type Friends=Array<string>;

            // //위에 타입을 따로 빼서 넣어준 것
            // type Player2={
            //     nickname:HealthBar,
            //     healthBar:HealthBar
            // }

            //플레이어는 오브젝트 타입
            // type Player={
            //     nickname:string,
            //     healthBar:number
            // }

            // const mofi:Player={
            //     nickname:"mofi",
            //     healthBar:10
            // }
            // //음식은 stiring 타입
            // type Food=string;
            // const tomato:Food="delicious"

            //특별한 타입을 따로 지정한 오브젝트 타입만들기
            // type Team="red" | "blue" | "yellow"
            // //이렇게 써주면 특정한 대가 중에 한 개만 특정하여 스트링타입으로 사용가능함

            // type Health=1|5|10

            // type SoccerPlayer={
            //     nickname:string,
            //     team:Team,
            //     health:Health
            // }
            // const mifi:SoccerPlayer={
            //     nickname:"mifi",
            //     team:"blue",
            //     health:1

            // }

            //위와 같은결과의 다른 방식
            // type User={
            //     name:string
            // }
            // type BasketP=User &{

            // }

            // const ruji: BasketP={
            //     name:"ruji"
            // }

            //추상클래스의 인터페이스화     구\구~구구
            // interface Ueser{
            //     //인터페이스에서는 생성자를 명명할 필요가 없다
            //     firstName:string,
            //      lastName:string ,
            //     // constructor(
            //     //     protected firstName:string,
            //     //     protected lastName:string
            //     // ){}
            //     //추상메서드라 나는 이걸 상속받으면 꼭 구현을 해야함
            //      sayHi(name:string):string
            //      fullName():string
            // }
            //임플리먼트랑 인터페이스는 타입스크립트에만 존재하서 좀더 가볍게 사용가능함
            //js로 변환했을때 코드에 뭔가 없음
            //그래서 임플리먼트로 받았을 때 여기에 생성자를 만들어서 사용
            //인터페이스의 퍼플릭 접근제한자만 사용가능(private도 못쓰고 무조건 퍼블릭만 쓸수 있나봐 )
            //인터페이스의 장점이나 단점이네
            //그리고 인터페이스는 2개이상의 타입을 상속(오브젝트)받을 수있다

            // interface Ball{
            //     // balltype:string,
            //     ballNum:number

            // }

            // class PlayerBasket implements Ueser, Ball{
            //     constructor(
            //         public firstName:string,
            //         public lastName:string,
            //         public ballNum:number,
            //         // public ballType:string       아니 왜안되는데???
            //     ){}
            //     fullName(){
            //         return `${this.firstName} ${this.lastName}`
            //     }
            //     sayHi(name:string){
            //         return `hello ${name}. My name is ${this.fullName()}`
            //     }
            // }

            // function makeUser(user:Ueser){
            //     return "hello";
            // }

            // makeUser({
            //     firstName:"mori",
            //     lastName:"chiyo",
            //     fullName:()=>"wooweak",
            //     sayHi:(name)=> "str"
            // });//함수화 하여 바로 만들기

            //큰일이 났구만 추상이랑 상속나와서 너무 어려워 ㅠㅠ
            //이번주 부터 빡시겠구만
            // }

            let num=0;
            //여기도 axois도 가능한가??
      //다형성, 제너릭(플레이스 홀더), +인터페이스


      // interface SStorage<T>{
      //     [key:string]:T
      // }

      // //재너릭T을 사용
      // class LocalStorgae<T>{
      //     private storge:SStorage<T>={}
      //         set(key:string, value:T){
      //             this.storge[key]=value;
      //         }
      //         remove(key:string){
      //             delete this.storge[key]
      //         }
      //         get(key:string):T{
      //             return this.storge[key]
      //         }
      //         clear(){
      //             this.storge={}
      //         }
      // }

      // //여기서 get메서드를 사용하면 제너릭에 따라서 스트링으로 세팅해준 값은 str로 나오고 블리언으로 세팅해준 객체는 블리언 값으 가지고 있음
      // const stringsStorage=new LocalStorgae<string>()
      // stringsStorage.get("key")
      // const boolensStorage=new LocalStorgae<boolean>()
      // boolensStorage.get("str")
      // boolensStorage.set("hello",true)







      // https://nomadcoders.co/typescript-for-beginners/lectures/3672
      //6:04 까지 시청
      //https://www.typescriptlang.org/play?#code/DYUwLgBAhgXBB2BXAtgIxAJwLwEYDcAUKJKnAM5gYCW8A5lgEQAWIwwA9g4cRAMZyp27UFHhZKiEN3DQMGOEjSYA2gF0synABoATKsK928MsJAA6DrQAUUOQEpCBMAE8ADiAgAFYFGeYsAN4EECEQGCBQACZGwM4IUMgg5JQ0tFrBoVC0IAD8MIroGAQAvgSGxpCuPn4YALJQANb+VvAJSRTUdHZw3r7+AHxBoWHgiBjwQ8OhrYkZIaWlZUYUEEyiUFhVfXWNmFbM6wwOSxUIVIab1Zj1TRj78Oecxw+GZlkguAAMhC-sZjMfADkLDY7EBjgA9BC+MtKld5EEoVMAclOmkCEjhu88gVMBAoTlACLjEEANQOASrHAC6rEEAAJOAE6aAH70qyAEkHAKgTxMAEqOAA1XAAOTEAAzIBbVYggAfRwANA4AE8cAOh0QQAjNWLABqrgAyGwAIvXYMdDioENci2nAGPB2MgoAwdYskeUVmRDQB3GC9GrazGZbIwHA6dLOkIohjW9g201I83Qy2QAAyzng8Ht8Kd0OGPojUcDmo1gBBxwALo4AcQYFgsAPOMyiQgYmAHi7AAATEEAHjWAG-bqZWdVQAGZWLY1N7ZCAAMk7EFbmHbIAAPDhPnYgmadX2MP82gQTisqGAQMgYOEojE4soOqktAgUIVd4JTKJ1MoGGAAG4MXc6T46D0QIv6BtL5CadT4Oc8KA4GCIeANLa8CEFCgCJ44Ao6PEgqgAkHYALl3QDggAa4xAgADPYAGEOAAMLgCh46WFaAKprgAe4xAFKAD6jgAWq4ASYQQIADhOAC41gAc3QWECAC0zgA2C1Y0CuFQEDZhAgCTo4AjW2ADqrgAxNRAgAnLYALaOACRj8GAC7jlYythVaSYAyY2AAc1EBNjKgAONYALp2AAx16pQk29G8YAIb0GYAPp0QIAEDXQYAMJMQIA1TOABE9gAfk1pjaAClNECABiNgAhPTKgAcg4AoMsEE2VguO47CNghWAJRABr7pgRyTCEPCoDgWA-gA1J+pSsGQHiRdFICxfFCW+ikdBpXMCFmGA7AAKquO4GAAMJQMVVjHMGgA1nYALIuAGOjvlkWhEAXuwVCRBAEqAJvNEAEYAu0MwFNM0QIAFsOACPNECABgtgAsdRAQmAA7NBCNv+vBgFQRirKwHC9elMLGKYFjsNYDAAB5HCU86QFArVYCCD3HEiAOuI1LVtZgXU9Q4IRQtJgAanTKgAvPXJgA7LRA2EZhAgANNYAPzU2WhrIKoAaeOACKjEAKppGbVoAADUQIAHO1znOQA

      >>>>>>> 90e0572f5e1412cacb18028f70ace5d8c6186a7e
    </script>
  </body>
</html>
