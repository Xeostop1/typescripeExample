<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // let a: number=1;
    // let b: string="hello";
    // let c: boolean=true;
    // let arr: number[]=[1,2];
    // console.log(arr);

    // const player:{
    //     name: string,
    //     age?:number //?을 사용해 준다~~(설정을 안할지 3항 연산자로 계산하나봐)
    // }={
    //     name: "noma"
    // }

    // //위에서 3항으로 true을 먼저 확인하고(위에 옵션이 있는지 보고 다음 비교연산자르 실행)
    //자바스크립트에서는 
    // if(player.age<10){ 이렇게 실행되서 뻑가는 경우가 많거든 ㅠㅠ}

    // if(player.age && player.age<10){

    // }
    // player.name
// type Player={
//      name: string,
//     age?:number
// }

// // const player:{
// //     name: string,
// //     age?:number //?을 사용해 준다~~(설정을 안할지 3항 연산자로 계산하나봐) 이게 너무 편하다~~
// // }={
// //     name: "noma"
// // }

// const snow:Player={
//     age:12,
//     name:"snow"
// }

// const Lynn:Player={
//     name:"Lynn"
// }


//알아서 상속 받는게 너무 편한데???? 대박스! 
//펑션에 플레이어라고 명시만 해주면 위의 타입을 모두 상속받는다
// type Player={
//      name: string,
//     age?:number
// }

//에로우 펑션
// const playerMaker=(name:string):Player=>{name};

//펑션형
// function playerMaker(name:string): Player{
//     return {name}
// }
// const playerMaker=(name:string): Player=>{
//     return{
//         name
//     }
// }

// const hana=playerMaker("hana");
// const nico=playerMaker("nico");
// nico.age=10;


//읽기전용 타입만들기 타입스크립트로 private을 알아서 걸어줬네! 캡슐화 시켜줬음
// const item:readonly [string, number, boolean]=["tv", 2022, true];
// item[1]=1;


//any
//자바스크립트의 허용을 쓰고 싶을 때 정의함 

// let a1:unknown;
// //작업을 하려면 a1의 변수타입을 먼저 확인 해야함→ 조건문으로 체크( api 에서 엉뚱한게 들어오면 이걸로 타입 걸어놓고 if로 거르기)
// //if문에서 분기를 갈려줌 첫번째 if는 넘버로 세팅
// if(typeof a1=== "number"){
//     let b1=a1+1;
// }
// else if(typeof a1==="string"){
//     a1.toUpperCase();
// }

// //리턴없는 함수 void 자동 인식:void 써도 되긴 한데
// function hello(){
//     console.log("x")
// }
// const aUp=hello();
// // aUp.toUpperCase();  //오류로 보이드 타입에 결과를 수정하잖아 하고 에러가 뜸


//never 
//이건 절대 리턴 안되는 곳에 쓰이는데 평소 펑션 에러 잡을 떄 좋겠다!! ex
// function hello(name:string|number) {
//         name:
// }




// type Add={
//     (a:number, b:number): number    //리턴도 넘버! 이걸알려주나봐
//     //(a:number, b:string): number    //리턴도 넘버! 이걸알려주나봐
//     (a:number, b:number, c:number):number
// }

// // const add =(a:number,b:number)=>a+b;

// // 타입을 미리 세팅하고 함수에 가져가서 사용하기
// const add: Add=(a,b)=> {
//     if(typeof b=="string")return a;
//     return a+b;
// }

// const add1:Add=(a,b,c?:number)=>{
//     return c? a+b+c:a+b;
// }

// add1(1,2);
// add1(1,3,2);

// type Config={
//     path: string,
//     state: object
// }

// type Push={
//     (path:string):void
//     (config:Config):void;
// }

// const push:Push=(config)=>{
//     //  if(typeof config==="string") {
//     //     console.log(config);
//     //  }else {
//     //     console.log(config.path, config.state);
//     //  }
    
//     typeof config==="string"? console.log(config):console.log(config.path, config.state);


// //다형성 폴리머피즘(多形)
// type SuperPrint={
//     // (arr:number[]):void
//     // (arr: boolean[]):void //리턴값이 없을때는 보이드라고 적어줌 
//     // (arr:string[]):void
//     //<T>(arr:T[])):void;   //제너릭 표현 그냥 나열만 해줘도 되네 
//     // <TypePlaceholder>(arr: TypePlaceholder[]):void;
//     // <PrintItem>(arr:PrintItem[]):void;  //제너릭을 정해주면 알아서 기본타입을 타입스크립트가 찾아줌 
// <PrintItem>(arr:PrintItem[]):PrintItem;  //리턴값이 있을 때는 똑같이 제너릭 써주만 돼 

// }
// // const superPrint:SuperPrint =(arr)=>{
// //     arr.forEach(i=> console.log(i));
// // }

// const superPrint:SuperPrint =(arr)=>    arr[0];


// const f=superPrint([1,2,3,4]);
// const g=superPrint([true,false,true]);
// const r=superPrint(["1","2"]);
// const e=superPrint([1,2,3,4,true]);




// }






// https://nomadcoders.co/typescript-for-beginners/lectures/3672
//6:04 까지 시청
//https://www.typescriptlang.org/play?#code/DYUwLgBAhgXBB2BXAtgIxAJwLwEYDcAUKJKnAM5gYCW8A5lgEQAWIwwA9g4cRAMZyp27UFHhZKiEN3DQMGOEjSYA2gF0synABoATKsK928MsJAA6DrQAUUOQEpCBMAE8ADiAgAFYFGeYsAN4EECEQGCBQACZGwM4IUMgg5JQ0tFrBoVC0IAD8MIroGAQAvgSGxpCuPn4YALJQANb+VvAJSRTUdHZw3r7+AHxBoWHgiBjwQ8OhrYkZIaWlZUYUEEyiUFhVfXWNmFbM6wwOSxUIVIab1Zj1TRj78Oecxw+GZlkguAAMhC-sZjMfADkLDY7EBjgA9BC+MtKld5EEoVMAclOmkCEjhu88gVMBAoTlACLjEEANQOASrHAC6rEEAAJOAE6aAH70qyAEkHAKgTxMAEqOAA1XAAOTEAAzIBbVYggAfRwANA4AE8cAOh0QQAjNWLABqrgAyGwAIvXYMdDioENci2nAGPB2MgoAwdYskeUVmRDQB3GC9GrazGZbIwHA6dLOkIohjW9g201I83Qy2QAAyzng8Ht8Kd0OGPojUcDmo1gBBxwALo4AcQYFgsAPOMyiQgYmAHi7AAATEEAHjWAG-bqZWdVQAGZWLY1N7ZCAAMk7EFbmHbIAAPDhPnYgmadX2MP82gQTisqGAQMgYOEojE4soOqktAgUIVd4JTKJ1MoGGAAG4MXc6T46D0QIv6BtL5CadT4Oc8KA4GCIeANLa8CEFCgCJ44Ao6PEgqgAkHYALl3QDggAa4xAgADPYAGEOAAMLgCh46WFaAKprgAe4xAFKAD6jgAWq4ASYQQIADhOAC41gAc3QWECAC0zgA2C1Y0CuFQEDZhAgCTo4AjW2ADqrgAxNRAgAnLYALaOACRj8GAC7jlYythVaSYAyY2AAc1EBNjKgAONYALp2AAx16pQk29G8YAIb0GYAPp0QIAEDXQYAMJMQIA1TOABE9gAfk1pjaAClNECABiNgAhPTKgAcg4AoMsEE2VguO47CNghWAJRABr7pgRyTCEPCoDgWA-gA1J+pSsGQHiRdFICxfFCW+ikdBpXMCFmGA7AAKquO4GAAMJQMVVjHMGgA1nYALIuAGOjvlkWhEAXuwVCRBAEqAJvNEAEYAu0MwFNM0QIAFsOACPNECABgtgAsdRAQmAA7NBCNv+vBgFQRirKwHC9elMLGKYFjsNYDAAB5HCU86QFArVYCCD3HEiAOuI1LVtZgXU9Q4IRQtJgAanTKgAvPXJgA7LRA2EZhAgANNYAPzU2WhrIKoAaeOACKjEAKppGbVoAADUQIAHO1znOQA



    </script>
</body>
</html>
